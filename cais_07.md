## 7. Статический анализ исходного кода с целью поиска ошибок. Методы поиска ошибок. Ограничения формальных подходов. Интерпретация результатов анализа.  Качество результата анализа.

### Анализ программ

**Анализ программы** – выявление фактов о программе

* **Динамический анализ** – анализ программы, использующий её выполнение. Пример – тестирование.

* **Статический анализ** – анализ программы без её запуска

    - Оптимизации программ (Компилятор)

    - Рефакторинг (Среда разработки)

    - Автоматическое документирование (Doxygen)

    - Обфускации / деобфускации программ (Dotfuscator, Ariadne)

    - Оценка метрик программы (качество, сложность, время работы, ...)

    - Поиска ошибок (FindBugs, Coverity, Klocwork, Svace)

### Статический поиск ошибок

Неформальный подход – поиск часто встречающихся ошибок

* Перекрёстная проверка кода.

    - Выполняется вручную – большие временные затраты

    - У людей похожие «слепые пятна» при просмотре

* Синтаксический анализ – автоматический поиск шаблонов в коде

Формальный подход – поиск всех ошибок или доказательство их отсутствия

* Верификация. Формальное доказательство соответствия программы её спецификации
  (модели).

    - Требует построения спецификации программы

* Проверка общих свойств – «Программа не бросает NullPointerException»

### Синтаксический анализ

* Автоматизация ручной проверки кода

* Более объективный анализ (нет «слепых» пятен)

* Поиск по шаблонам. Какой код с высокой вероятностью содержит ошибку?

* Примеры шаблонов:

```
if (x = y) {
    ...
}

for (int x; x < y; x++) {
    ...
}
```

* Подходит для локальных шаблонов.

* Не подходит для проверки на длинных путях программы

### Верификация

* Золотой стандарт, абсолютная гарантия

* Используются формальные методы:

    - Доказательство теорем

    - Проверка моделей

* Необходима полная спецификация программы

* Анализ потока данных по всем возможным путям программы

* Слишком дорогой метод для массового использования:

    - Большие временные затраты по разработке спецификации

    - Высокие требования к создателям спецификации

    - Процесс проверки может быть очень долгим

* Используется в критически важных системах:

    - Космос, транспорт, энергетика, ...

### Проверка свойств

* Не требуется спецификация программы

* Используются общие стандартные спецификации безопасности – ограничивая
  корректное использование объектов. Например:

    - «Мьютекс должен быть освобождён после блокирования и может быть захвачен
      только после освобождения»

    - «Файл должен быть закрыт после того как был открыт и должен быть открыт
      после того как был закрыт»

    - «Память не должна использоваться после того как была освобождена и не
      должна освобождаться дважды»

* В случае простых объектов используются конечные автоматы:

===

### Ограничения формального подхода

* Задача автоматической проверки нетривиального свойства произвольной программы
  алгоритмически неразрешима (Теорема Райса):

1. Есть ли в программе P ошибка X? =

2. Достигает ли программа P состояния X? =

3. Проблема останова

* Невозможно реализовать универсальную проверку свойств, но для конкретной
  программы задача разрешима.

* Проверка свойств и верификация подразумевает два свойства:

    - Полнота – обнаруживаются все ошибки

    - Безошибочность – отсутствуют ложные срабатывания

* Поиск ошибок – отказ от одного или обоих свойств.

    -  Требуется найти некоторые (возможно критические) ошибки

### Анализ состояний программы

* Аппроксимации при поиске ошибок:

```
╭───────────────────────────────────────────────╮
│           ╭───────────╮                       │
│          ╭┼───────────┼─────────────────────╮ │
│ «Полный» ││ Ошибочные │                     │ │
│  анализ  ││ состояния │                     │ │
│          ││        ╭──┼───────╮ Достижимые  │ │
│          │╰────────┼──╯       │ состояния   │ │
│          │         │ «Точный» │             │ │
│          │         │  анализ  │             │ │
│          │         │          │             │ │
│          │         ╰──────────╯             │ │
│          ╰──────────────────────────────────╯ │
╰───────────────────────────────────────────────╯
```

    - Отказ от безошибочности. Анализ надмножества состояний.

Гарантируют полноту (все ошибки + ещё что-то). Тривиальная реализация –
возвращаем что всё ошибочно

    - Отказ от полноты. Анализ подмножества состояний гарантирует безошибочность
      (все ошибки истинны, но часть пропущена).  Тривиальная реализация —
возвращаем, что ошибок нет.

* На практике используется гибридный эвристический подход - больше гибкости в
  определении вероятного поведения программы. Позволяет анализу быть более
точным в общем случае.

### Основное ограничение статического анализа

* «Экспоненциальный взрыв» – быстрый рост числа путей в программе с ростом
программы.

* Вывод – анализы чувствительные к пути неприменимы к реальным программам

* Возможное решение – группировка путей, объединение состояний в точках слияния
нескольких путей

    - may-анализ – анализ надмножества состояний *E₃ = E₁ ∪ E₂*

    - must-анализ – анализ подмножества состояний *E₃ = E₁ ∩ E₂*

### Как оценить качество анализа?

*A* — Все ошибки в программе

*B* — Сообщения об ошибках

*B − A* — False positives, ложные срабатывания

*A − B* — False negatives, ненайденные ошибки

*A ∩ B* — True positives, найденные истинные ошибки

*All − A − B* — True negatives, ненайденные лажные срабатывания

**Полнота** – доля истинных ошибок среди всех ошибок в программе *|A ∩ B|/|A|*

**Точность** – доля истинных ошибок среди всех обнаруженных *|A ∩ B|/|B|*
