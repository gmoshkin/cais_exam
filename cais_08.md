## 8. Представления программы, использующиеся при поиске ошибок в исходном коде.  Потоковая и контекстная чувствительность. Типы обнаруживаемых ошибок. Путь распространения ошибки.

### Модели программы

* Исходный код, как представление программы для анализа неудобен

* Используются модели, разработанные в области компиляторов

* Лексический анализ – программа, как поток токенов

* Синтаксический анализ – абстрактное синтаксическое дерево

* Семантический анализ – проверка типов

* Построение промежуточного представления

    - Более высокоуровневого чем для компилятора

* Построение модели программы, позволяющей анализировать потоки данных и
  управления.  Используемые модели:

    - граф потока управления (ГПУ) и граф вызовов (ГВ)

    - граф зависимостей(ГЗ)

### Граф потока управления

##### Программа:
```
int n = 10;
int f = 1;
while (n > 0) {
    f = f * n;
    n = n – 1;
}
res = f;
```

##### ГПУ:
```
  ┏━━━━━━━┓
  ┃ n =10 ┃
  ┃ f = 1 ┃
  ┗━━━┯━━━┛
      │
      ▾
  ┏━━━━━━━┓
┌─┨ n > 0 ┃‹┐
│ ┗━━━┯━━━┛ │
│     │     │
│     ▾     │
│ ┏━━━━━━━┓ │
│ ┃f = f*n┃ │
│ ┃n = n-1┠─┘
│ ┗━━━━━━━┛
│ ┏━━━━━━━┓
└›┃res = f┃
  ┗━━━━━━━┛
```

* Анализ выполняющийся по ГПУ без использования графа вызовов –
  внутрипроцедурный

* Вершинами могут быть как базовые блоки так и отдельные инструкции (менее
  компактно)

### Граф зависимостей (ГЗ)

* Инструкция S зависит по данным от инструкции T если существует путь от T к S и
  значение переменной определяется в T используется в S (DU-зависимость).

* Зависимости по данным между узлами-инструкциями представляются в виде
  направленных рёбер

* На практике помимо рёбер DU-зависимостей (запись-чтение) также используются
  зависимости вида:

    - чтение-запись (UD)

    - запись-запись (DD)

* Зависимости по управлению

### Граф зависимостей по данным

[вставь картинку]

### Граф вызовов (ГВ)

[вставь картинку]

Анализ выполняющийся с использованием графа вызовов – межпроцедурный

Требуется проверять корректность вызовов – количество и тип параметров

### Сложности построения графа вызовов – вызов по указателю

[вставь картинку]

Требуется анализировать возможные значения указателей

### Граф указателей

[вставь картинку]

Граф, который для данной точки программы содержит рёбра между переменными p и x
если p может/должно указывать на x

### Связь между анализом потоков управления и данных

* Внутрипроцедурный анализ потока управления (ГПУ) обеспечивает:

    - определение последовательности анализируемых конструкций

* Межпроцедурный анализ потока управления (ГВ):

    - определяет последовательность анализа функций

    - обеспечивает передачу параметров в вызываемые функции и возвращаемого
    значения в точку вызова

* Анализ потока данных обеспечивает (ГЗ):

    - определение возможных значений переменных во всех точках программы

    - определение недостижимых переходов

    - вызов функций по указателю (ГУ)

### Алиасы (псевдонимы)

* Набор различных выражений, которые обозначают одну и ту же переменную

* Примеры конструкций, порождающих алиасы:

    - Использование указателей

        + В частности, указателей на функции

    - Элементы массивов (индексные выражения)

    - Объединения (union)

* Алиасы представляют проблему, для анализа потоков данных и управления:

    - Состояние какой переменной меняется в инструкции?

    - Какая функция (набор функций) должна/может быть вызвана по указателю в
      данной точке вызова?

* Анализ алиасов (в частности, анализ указателей)

===

### Чувствительность анализа

* Чувствительность к пути – способность анализа различать разные пути в
программе

* Чувствительность к потоку – способность анализа различать порядок следования
инструкций

* Чувствительность к контексту – способность анализа различать разные вызовы
одной функции

* Внутрипроцедурность/Межпроцедурность – анализ потоков данных только внутри
одной функции/между функциями

===

### Типы обнаруживаемых ошибок

* Ошибки работы с ресурсами:

    - утечки памяти или других ресурсов:
        + при выходе из функции (забыли поставить free)
        + при потере указателя на память (указатель затирается новым значением)

    - неверная последовательность операций (двойное освобождение)

    - ошибки при работе с многопоточными примитивами;

* Ошибки ввода/вывода

    - Форматная строка
        + использование внешних данных в качестве форматной строки

    - Использование опасных функций (`gets`)

* Арифметические ошибки:

    - Деление на ноль

* Использование неинициализированных значений
    - использование неициализированной переменной
    - разыменование неициализированного указателя

* Ошибки работы с памятью:

    - Разыменование нулевого указателя

    - Выход за границы буфера

### Путь распространения ошибки

Цель обнаружения ошибки – её устранение.

Ошибка обнаруживается в месте её проявления в программе – выполнение
  некорректной или опасной инструкции.

Исправление может требоваться в другом месте.

* **Путь распространения ошибки** – поток данных в программе, приведший к ошибке.
  Делится на 3 части:

    - Источник (source) – место инициализации переменных, значения которых
привели к ошибке.

    - Распространение (propagation) – инструкции, участвовавшие в
обработке/передаче значений, которые привели к ошибке

    - Место проявления ошибки (sink) – инструкция, приводящая к ошибке

===

### Общая схема поиска ошибок

[вставь картинку]

### Описание ошибки

Каждый тип ошибки характеризуется:

* Список источников – инструкции, порождающие значения, впоследствии
  приводящие к ошибке

* Список правил – описание того, как различные инструкции влияют на
  значение, приводящее к ошибке

* Список инструкции приводящих к проявлению ошибки и условия её
  возникновения

#### Пример описания ошибки «разыменование нулевого указателя»:

* Источники – операции инициализации указателя

* Правила – операции присвоения

* Проявление ошибки – разыменование указателя, при условии, что указатель
  может быть равен нулю.

### Анализ программ на основе состояний

Определяются состояния объектов программы во всех точках программы (между
выполнением инструкций)

**Состояние программы** – возможные состояния всех объектов, видимых в данной
точке программы

Различные типы объектов программы: переменные, указатели, файлы, ...

Для разных типов объектов – разные состояния:

* Переменные – возможные значения

* Указатели – равенство нулю, объекты на которые может указывать

* Файл – открыт/закрыт на чтение/запись

### Алгоритмы определения состояний

Для анализа состояний разных объектов используются различные алгоритмы:

* Алгоритм анализа значений

* Алгоритм анализа указателей

* Алгоритм ресурсного анализа

Алгоритмы анализа представлены в виде правил для конструкций программы

Каждое правило формирует уравнение, над состояниями объектов программы

*Rule(S(l))→ Eq(S(l), S(l + 1))*

Строится система уравнений, решение которой даёт состояния объектов программы во
всех точках

### Алгоритм поиска ошибки

1. Найти в модели программы инструкции источники ошибки.

2. Проинициализировать состояния объектов в соответствии с типом ошибки.

3. Распространить состояния объектов по графу потока управления программы с
   учётом графа вызовов в соответствии с правилами ошибки – получить состояния в
каждой точке программы .

4. Найти в модели программы инструкции, которые могут приводить к проявлению
   ошибки.

5. Проверить в них состояние программы в соответствии с условиями возникновения
   ошибки.

### Преимущества использования статического анализа

* Раннее обнаружение ошибок – во время разработки

* Код при этом может не собираться и не запускаться

* Полное покрытие кода

* Не требуется задавать тестовые входные данные

* Лучше проверяет участки кода сложные для тестирования (обработка ошибок)

### Ограничения статического анализа

* Не является заменой тестирования (не проверяет логику программ)

* Отсутствие знаний о входных значениях (неопределённые значения переменных)

* «Экспоненциальный рост» числа путей в программе

* Большая длина отдельных путей в программе (циклы рекурсивные вызовы)

* Сложность анализа циклов и рекурсивных вызовов (сколько раз выполнялись?)

* Проблема «алиасов»

* Возможность отсутствия части кода программы (библиотек)

* Большой объём данных описывающих состояния программы (возможные значения)

### Аппроксимации алгоритмов статического анализа

* Сокращение числа анализируемых путей выполнения:

    - совместный анализ путей выполнения программы

* Сокращение длины анализируемых путей:

    - ограничение на глубину стека вызовов

    - ограничение на число итераций при анализе циклов

* Сокращение объёма данных, связанных с путями:

    - сокращение количества анализируемых объектов, например представление
      массива одним объектом

    - компактное хранение состояний объектов: вместо 1,2,..10 – интервал (1,10)

* Возможность аннотации внешних функций в виде некоторой суммы их влияния на
  данные:

    - «OpenFile() возвращает созданный объект типа файл или 0»

### Автоматизация

Уровень автоматизации:

* Количество входных данных и действий, требуемых от пользователя перед
  началом анализа

    - Необходимость аннотации внешних функций,

    - Необходимость создания специальной сборки проекта

* Возможность предоставления дополнительных данных для уточнения анализа

    - дополнительная аннотация кода

* Дополнительная обработка выдаваемых ошибок

    - Возможность ранжирования выдаваемых ошибок по серьёзности, вероятности
      истинности и т.д.

    - Возможности по проверке истинности выданных ошибок
