10. Вычисление необходимых условий для поиска переполнения буфера. Понятия полноты и корректности. Примеры абстракций: интервальная абстракция, предикатная абстракция. SMT-решатели.

### Поиск выхода за границы массива

Рассмотрим ошибку выход за границы массива.

Пусть происходит обращение к массиву размера *N*, `a[i] = b`;

Тогда, ошибка выход за границы массива произойдёт в том случае, если *∃ σ ∈
P{a[i]=b} ∶ σᵢ ≥ N ∨ σᵢ < 0*

Посчитать *P{a[i]=b}* не получится, зато можно посчитать *φ(l{a[i]=b}) ∶
P{a[i]=b} ⊆ φ(l{a[i]=b})*

### Корректность и полнота

* Пусть происходит обращение к массиву размера *N*, `a[i] = b`;

* Пусть известно *φ(l{a[i]=b})*

* Тогда необходимое условие ошибки формулируется как :

*∃σ ∈ φ(l{a[i]=b}) ∶ σᵢ ≥ N ∨ σᵢ < 0*  
⇑  
*∃σ ∈ P{a[i]=b} ∶ σᵢ ≥ N ∨ σᵢ < 0*

* Необходимое условие ошибки обладает свойством корректности, т.е. не пропускает
  ошибки.

* Достаточное условие ошибки:

*∀ σ ∈ φ(l {a[i]=b} ) ∶ σᵢ ≥ N ∨ σᵢ < 0*

* Достаточное условие ошибки обладает свойством полноты, т.е. не находит ложные
  ошибки.

*Полнота* – не находит ложные ошибки
*Корректность* – не пропускает ошибки

===

### Поиск необходимых условий.  Анализ интервалов значений

Анализ интервалов значений вычисляет в каждой точке программы интервалы,
покрывающие все возможные значения переменных.

Интервалы значений позволяют обнаруживать инвариантные условия в программе.

### Решётка интервалов

* Элементами решётки для одной целочисленной переменной являются интервалы *[a,
  b]*

* Частичный порядок определяется отношением включения *⊆*

* Наименьшая верхняя граница для нескольких интервалов вычисляется при помощи
  объединения *∪*

### Вычисление интервалов значений

Передаточные функции для арифметических операций основываются на интервальной
арифметике.

для переменных `x` и `y` с интервалами значений *[a, b]* и *[c, d]* и константы
`k`:

`x = k` : *[k, k]*

`x + y` : *[a, b] + [c, d] = [a + c, b + d]*

`x - y` : *[a, b] – [c, d] = [a – c, b – d]*

`x * y` : *[a, b] * [c, d] = [min(ac, ad, bc, bd), max(ac, ad, bc, bd)]*

`x / y` : *[a, b] / [c, d] = [min(a/c, a/d, b/c, b/d), max(a/c, a/d, b/c, b/d)]*

### Вычисление интервалов значений

Передаточные функции для сравнений.

для переменных `x` и `y` с интервалами значений *[a, b]* и *[c, d]* и константы
`k`:

Сравнение : Вычисление интервалов значений для x и y в результате сравнения

`assume x == y` :

`x`: *[a, b] ∩ [c, d]*

`y`: *[a, b] ∩ [c, d]*

`assume x > y`

`x`: *[a, b] ∩ [c + 1, +inf]*

`y`: *[-inf, b - 1] ∩ [c, d]*

`assume x ≤ y`

`x`: *[a, b] ∩ [-inf, d]*

`y`: *[a, +inf] ∩ [c, d]*

`assume x ≠ k`

`x`: *[a + 1, b], when k = a*

`x`: *[a, b + 1], when k = b*

`x`: *[a, b], when k ∈ [a + 1, b - 1]*

`x`: *∅ , when k ∉ [a, b]* ← this is bullshit

### Необходимость widening

Поскольку полурешётка интервалов имеет бесконечную высоту, то анализ потока
данных не будет сходиться.

```
// n ∈ [-inf, +inf]
for (i = 0; i < n; ++i) {
    // i ∈ [0, 0] 1-st dataflow iteration
    // i ∈ [0, 1] 2-nd dataflow iteration
    // i ∈ [0, 2] 3-rd dataflow iteration
    // ...
    // i ∈ [0, +inf]
}
```

Чтобы анализ сошёлся, мы применяем *widening*:

внутри цикла на очередной итерации анализа при перевычислении интервала в точке
программы:

1. при расширении границы интервала, она сразу заменяется на inf

2. левая граница интервала не смещается вправо, а левая не смещается влево

### Пустой интервал значений

* На инструкциях сравнения может быть вычислен пустой интервал.

пустой интервал свидетельствует о том, что сравнение инвариантно: результат
сравнения всегда ложный

```
// x ∈ [0, 1]
// y ∈ [3, 7]
if (x == y) { // assume x = y
    ... // [0, 1] ∩ [3, 7] = ∅
    ... // unreachable code
}
```

* Недостижимому коду соответствует значение ⊥ из полурешётки для всех
  переменных.

### Неучитывание выколотой точки

* Интервальная абстракция не учитывает выколотые точки.

* Из-за нехватки точности анализ не обнаруживает многие инвариантные сравнения

```
if (x != 0) { // assume x ≠ 0
    // ???
    if (x == 0) { // assume x = 0
        // x ∈ [0, 0]
        // unreachable code?
        ...
    }
}
```

### Анализ нулевой выколотой точки

Дополним интервальную абстракцию анализом выколотого нуля.

*⊥* (unreachable) *⊆ x ≠ 0 ⊆ ⊤*

Инструкция : Значение потока данных

`x = 0` : *⊤*

`x = k` : *x ≠ 0 , when k ≠ 0*

`assume x ≠ 0` : *x ≠ 0*

`assume x = 0` : *⊥ , если x ≠ 0*


### Неучитываемые сравнения

В описанном анализе не учитываются сравнения тех переменных, которым
сопоставлены значения *⊤*

```
void foo(int a, int b) {
    if (a > b) {
        if (a <= b) {
            // unreachable code?
        }
    }
}
```

Учесть подобные ситуации можно при помощи вычисления необходимых условий
достижения точек программы

===

### Предикатная абстракция

Анализ производится над программой, переведённой в SSA- форму

Предикатный анализ вычисляет необходимые условия достижения точек программы

Вычисляемые условия – конъюнкции, состоящие из предикатов инструкций сравнения

```
1: void foo(int a1 , int b1 ) {
2: if (a1 > b1 ) { // a1 > b1
3: if (b1 != 3) {// a1 > b1 && b1 != 3
4: }
5: // a1 > b1
6: } else {
7: // a1 <= b1
8: }
9: }
```

### Решётка предикатной абстракции

Элементами решётки для точки программы являются конъюнкции предикатов,
содержащихся в программе (предикаты обозн. A, B, C, ... )

Предикат – либо атомарное сравнение двух переменных, либо определение значения
переменной.

Каждая конъюнкция рассматривается как множество предикатов

Частичный порядок конъюнкций определяется отношением вложенности этих множеств ⊆

Наименьшая верхняя граница для набора конъюнкций вычисляется при помощи их
пересечения *∪*

*P′∩ P′′* – содержит только общие коньюкты для *P′* и *P′′*

### Условие ошибок при предикатной абстракции

Пусть *Pᴮ* − необходимое условие для текущей точки.

Пусть *V* − множество переменных в программе, *v* - вектор переменных. По
построению *Pᴮ* зависит от *v* , т.е. *Pᴮ(v)*

Необходимое условие ошибки: *∃v : Pᴮ(v) ∧ (N ≤ i ∨ 0 > i)*

Достаточное условие ошибки: *∀v : Pᴮ(v) ∧ (N ≤ i ∨ 0 > i)*

Данные формулы можно решать при помощи SMT-солвера.

===

### SMT-решатели

Программы для решения уравнений в различных теориях.

Обобщение SAT-задачи.

Допускается использование кванторов, целочисленной арифметики, битовой
арифметики и т.д.

Стандартный язык для решателей – SMTLib2.

Примеры решателей: Z3, CVC4

### Символьное выполнение

Идея: вместо того, чтобы рассматривать все возможные пути, рассмотрим один
конкретный путь.

Для выбранного пути проведем абстрактную интерпретацию

Плюсы: Полученное необходимое условие для пути, будет точнее, т.к. нет операций
сбора.

Минусы: Нельзя перебрать все пути.

### Разные чувствительности

Чувствительность к потоку (flow sensitivity): анализ учитывает порядок
инструкций

Чувствительность к путям (path sensitivity): анализ учитывает условия переходов

Чувствительность к контексту (context sensitivity): анализ учитывает вызовы
функций
